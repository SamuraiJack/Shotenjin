<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
	<head>
		<link type="text/css" rel="stylesheet" href="http://joose.it/markdown.css " />
	</head>
<body>
<h1 id="name">Name</h1>

<p>Shotenjin - Post-modern JavaScript template engine</p>

<h1 id="synopsis">SYNOPSIS</h1>

<p>Always classic:</p>

<pre><code>    var tenjin = new Shotenjin.Template({
        sources : 'Hello [% world %]'
    })

    var rendered = tenjin.render({
        world : 'world'
    })
</code></pre>

<p>Post-modern:</p>

<pre><code>    Template('Table.Cell', {
        template : '&lt;td&gt;[% text %]&lt;/td&gt;'
    })


    Template('Table.Row', {
        use : 'Table.Cell',

        template : '&lt;tr&gt;[%\\ Joose.A.each(row, function (cell, index) { %][%= Table.Cell({ text : cell }) %][%\\})%]&lt;/tr&gt;'
    })


    Template('Table', {
        use : 'Table.Row',

        template : '&lt;table&gt;[%\\ Joose.A.each(table, function (row, index) { %][%= Table.Row({ row : this.helper(row) }) %][%\\})%]&lt;/table&gt;',

        methods : {

            helper : function () { ... }
        }
    })


    var tableData = [
        [ '1',  '1', '2' ],
        [ '3',  '5', '8' ],
        [ '13','21','34' ]
    ]


    var rendered = new Table({ table : tableData })

    // or just

    var rendered = Table({ table : tableData })
</code></pre>

<p>Less-noisy with the helper script:</p>

<pre><code>    Template('Chapter', {

        template : {
            /*tj
                &lt;h2&gt;[% title %]&lt;/h2&gt;
                &lt;p&gt; [% content %]&lt;/p&gt;
            tj*/

            /* GENERATED BY SHOTENJIN HELPER, DO NOT MODIFY DIRECTLY */
            sources : '&lt;h2&gt;[% title %]&lt;/h2&gt;\n&lt;p&gt; [% content %]&lt;/p&gt;'
        }
    })


    Template('Book', {

        template : {
            /*tj
                [%\ this.wrapper(Chapter, { title : 'Chapter1' }, function () { %]                     
                    Text of first chapter.
                [%\ }); %]

                [%\ this.wrapper(Chapter, { title : 'Chapter2' }, function () { %]
                    Text of second chapter.
                [%\ }) %]
            tj*/

            /* GENERATED BY SHOTENJIN HELPER, DO NOT MODIFY DIRECTLY */
            sources : '[%\\ this.wrapper(Chapter, { title : \'Chapter1\' }, function () { %]                     \nText of first chapter.\n[%\\ }); %][%\\ this.wrap(Chapter, { title : \'Chapter2\' }, function () { %]\nText of second chapter.\n[%\\ }) %]'
        }
    })

    var rendered = Book()
</code></pre>

<p>If you are reading this file as README from github, you may want to open <a href="http://samuraijack.github.com/Shotenjin">this link</a> instead. </p>

<h1 id="installation">INSTALLATION</h1>

<p>From <code>npm</code>:</p>

<pre><code>&gt; [sudo] npm install shotenjin
</code></pre>

<p>Tarballs are available for downloading at: <a href="http://search.npmjs.org/#/shotenjin">http://search.npmjs.org/#/shotenjin</a></p>

<h1 id="setup">SETUP</h1>

<p>In NodeJS:</p>

<pre><code>require('task-joose-nodejs')
require('shotenjin')
</code></pre>

<p>In browsers (assuming you've completed the 3.1 item from this <a href="http://joose.github.com/Joose/doc/html/Joose/Manual/Installation.html">document</a>):</p>

<pre><code>&lt;script type="text/javascript" src="/jsan/Task/Joose/Core.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="/jsan/Task/Shotenjin/Core.js"&gt;&lt;/script&gt;
</code></pre>

<h1 id="description">DESCRIPTION</h1>

<p>Shotenjin is a Yet Another JavaScript Templating Engine, based on Tenjin by <a href="http://www.kuwata-lab.com/">Makoto Kuwata</a>
Shotenjin was ported to Joose, along with some improvements.</p>

<p>The main difference of Shotenjin from other templating solutions is that for the templating language it uses JavaScript itself. 
Thus, Shotenjin templates are not <em>compiled</em> into JavaScript, they are only <em>parsed</em>. </p>

<h1 id="syntax">SYNTAX</h1>

<p>Shotenjin uses 3 types of template instructions. Keep in mind, that all them, in the same time, are just ordinary JavaScript expressions,
which are evaluated directly by the JavaScript engine of your choice, in the context of the template function (see below for its internal structure). </p>

<h2 id="escapedexpressions">Escaped expressions</h2>

<p>Such expression are represented with the following construct:</p>

<pre><code>    [% name %]

    [% name + ' ' + surname %]

    [% Digest.MD5.md5_hex(response) %]
</code></pre>

<p>The value of the expression will be escaped before adding to template, according to this table:</p>

<pre><code>    '&amp;'     : '&amp;amp;'
    '&lt;'     : '&amp;lt;' 
    '&gt;'     : '&amp;gt;' 
    '"'     : '&amp;quot;'
</code></pre>

<h2 id="unescapedexpressions">Unescaped expressions</h2>

<p>Such expression are represented with the following construct</p>

<pre><code>    [%= person.name %]

    [%= document.body.innerHTML %]
</code></pre>

<p>Memo - passed-through exactly (equally) as calculated</p>

<p>The value of the expression will <em>not</em> be escaped before adding to template. Thus, this expressions can be used to generate HTML markup. <br />
This instruction can be used to include the resulting content of another template for example, (see example with <code>Table</code> in Synopsys above)</p>

<h2 id="controlstatements">Control statements</h2>

<p>This type of instructions represent arbitrary JavaScript code, which will be added to template function unmodified. So, generally, 
it shouldn't return a value, but should modify the control flow:</p>

<pre><code>    [%\ for (var i = 0; i &lt; persons.length; i++) { %]
            &lt;tr&gt;&lt;td&gt;[% persons[i].name %]&lt;/td&gt;&lt;/tr&gt;
    [%\ } %]        


    [%\ if (a == b) { %]
            &lt;tr&gt;&lt;td&gt;[% person.name %]&lt;/td&gt;&lt;/tr&gt;
    [%\ } else { %]        
            &lt;tr&gt;&lt;td&gt;[% person.surname %]&lt;/td&gt;&lt;/tr&gt;
    [%\ } %]
</code></pre>

<p>Multi-line code is ok:</p>

<pre><code>    [%\
        var sum = 0

        Joose.A.each(persons, function (person, index) {
            sum += person.parameter
        })
    %]
    Totally: [% sum %]
</code></pre>

<p>Memo - lambda function in Haskell.</p>

<p>As you can see any code can be embedded into templating function, and you don't need to learn one more language to create a template.</p>

<h1 id="usage">USAGE</h1>

<h2 id="classic">Classic</h2>

<p>Shotenjin can be used in "classic" way, in which you are responsible for instantiation and rendering: </p>

<pre><code>    var tenjin = new Shotenjin.Template({
        sources : 'Hello [% world %]'
    })

    var rendered = tenjin.render({
        world : 'Shotenjin'
    })
</code></pre>

<h2 id="post-modern">Post-modern</h2>

<p>In the "post-modern" usage scenario, the template instance is embedded into Joose class:</p>

<pre><code>    Class('Table.Cell', {
        meta : 'Shotenjin',

        template : '&lt;td&gt;[% text %]&lt;/td&gt;'
    })
</code></pre>

<p>Additional helper <code>Template</code> is introduced to simplify the declaration:</p>

<pre><code>    Template('Table.Cell', {

        template : '&lt;td&gt;[% text %]&lt;/td&gt;'
    })
</code></pre>

<p>By default, the class with the embedded template is a subclass of <code>Shotenjin.Template</code>. </p>

<p>You can define additional methods (they will be available in templating function) or attributes, inherit from another template,
apply Roles or something else. Please refer to <a href="http://bit.ly/joose_manual">Joose manual</a> to know what you can do with Joose classes.
A simple example:</p>

<pre><code>    Template('Table.Cell', {

        use : 'Text.Format',

        template : '&lt;td&gt;[% this.cellFormatter(text) %]&lt;/td&gt;'

        methods : {

            cellFormatter : function (value) {
                ...
            }
        }
    })
</code></pre>

<p>The created <code>Table.Cell</code> class will be a singleton, which is instantiated internally. Its external constructor (<code>Table.Cell</code>) will be 
binded to the <code>render</code> method, so, to render the template, call the constructor with the required data:</p>

<pre><code>    var rendered = new Table.Cell({ text : 'some text' })

    // or just

    var rendered = Table.Cell({ text : 'some text' })
</code></pre>

<p><strong>Note</strong>: Constructor will return instance of String (new String()), so in the example above the following will be true: `typeof rendered == 'object``</p>

<p>Naturally, you can easily include such template into another template: </p>

<pre><code>    Template('Table.Row', {
        use : 'Table.Cell',

        template : '&lt;tr&gt;[%\\ Joose.A.each(row, function (cell, index) { %][%= Table.Cell({ text : cell }) %][%\\})%]&lt;/tr&gt;'
    })
</code></pre>

<h2 id="helperscript">Helper script</h2>

<p>You may have noticed, that writing templates into JavaScript can be a cumbersome task, because you need to manually escape each special symbol, like <code>\</code>
To address this issue <code>Shotenjin</code> comes with the helper script <code>shotenjin_embed.pl</code>. Its a simple shell script, which examine the passed file 
(or files in directory) for the templates, embedded into JavaScript comments <code>/*tj ... tj*/</code></p>

<pre><code>    Template('Book', {

        template : {
            /*tj
                [%\ this.wrapper(Chapter, { title : 'Chapter1' }, function () { %]                     
                    Text of first chapter.
                [%\ }); %]

                [%\ this.wrapper(Chapter, { title : 'Chapter2' }, function () { %]
                    Text of second chapter.
                [%\ }) %]
            tj*/
        }
    })
</code></pre>

<p>Once found, script append such comments with the escaped version of the template:</p>

<pre><code>    Template('Book', {

        template : {
            /*tj
                [%\ this.wrap(Chapter, { title : 'Chapter1' }, function () { %]                     
                    Text of first chapter.
                [%\ }); %]

                [%\ this.wrap(Chapter, { title : 'Chapter2' }, function () { %]
                    Text of second chapter.
                [%\ }) %]
            tj*/

            /* GENERATED BY SHOTENJIN.JOOSED HELPER, DO NOT MODIFY DIRECTLY */
            sources : '[%\\ this.wrap(Chapter, { title : \'Chapter1\' }, function () { %]                     \nText of first chapter.\n[%\\ }); %][%\\ this.wrap(Chapter, { title : \'Chapter2\' }, function () { %]\nText of second chapter.\n[%\\ }) %]'
        }
    })
</code></pre>

<p>Also, its possible to extract the content of the template from the external file:</p>

<pre><code>    Template('Book', {

        template : {
            /*tjfile(Book.tj.html)tj*/
        }
    })
</code></pre>

<p>By default, the location of the template file is determined relative of the source file itself, you can switch the relativity to the current working directory with the <code>--absolute</code> option.</p>

<p>Script is supposed to be run during your project's build phase. All modern IDE will allow you to automatically run the script, when one of the files in the project was modified,
so spend some time to examine your IDE's documentation for that.</p>

<p>Script accepts a single command-line argument, which should be either the path to file to examine, or the directory, which will be scanned for all <code>*.js</code> files.</p>

<p>Script also accepts an <code>--absolute</code> option, which will makes it to look for template files relative of current working directory.   </p>

<h1 id="api">API</h1>

<p>During evaluation of the template, <code>this</code> value is associated with the instance of <code>Shotenjin.Template</code> (or its subclass), so naturally all the methods of this class are available.</p>

<h2 id="methods">Methods</h2>

<ul>
<li><code>this.render(Object stash)</code></li>
</ul>

<p>Renders the template using data, passed in <code>stash</code></p>

<ul>
<li><code>this.capture(Function func)</code></li>
</ul>

<p>Captures the output, generated inside the passed function and returns it. For example:</p>

<pre><code>[%\ var names = this.capture(function () {
        for (var i = 1; i &lt;= 5; i++) { 
%]
            [% persons[i].name %]
[%\     }
    })
%]

[% names %]
</code></pre>

<p>A <em>new context</em> is derived for the passed function and the output of the outer template isn't modified. </p>

<ul>
<li><code>this.echo(Object str1, Object str2, ...)</code></li>
</ul>

<p>Escapes and adds each of passed arguments to the output of the <em>current context</em>. Usually a <em>context</em> is a template itself, however nested contexts may be derived (see <code>this.capture</code> and <code>this.wrapper</code>)</p>

<ul>
<li><code>this.echoRaw(Object str1, Object str2, ...)</code></li>
</ul>

<p>Unescaped version of <code>echo</code>.</p>

<ul>
<li><code>this.wrap(Class|Shotenjin.Template template, Object stash, Function func)</code></li>
</ul>

<p>First captures the content generated into the passed <code>func</code>, then assign it to the <code>content</code> key of the passed <code>stash</code> object and renders the wrapping template with it.
Wrapping <code>template</code> can be passed as the instance of <code>Shotenjin.Template</code> or as Class.</p>

<ul>
<li><code>this.escapeXml(String str)</code></li>
</ul>

<p>Escapes reserved HTML symbols in the <code>str</code> and returns modified string. Override this method if you need to implement more precise escaping rules. </p>

<h2 id="attributes">Attributes</h2>

<p>These attributes can be either passed to constructor ("classic" way) or specified for class using <code>has</code> builder ("post-modern" way)</p>

<ul>
<li><code>startTag</code></li>
</ul>

<p>String for opening tag. Default value is <code>[%</code></p>

<ul>
<li><code>endTag</code></li>
</ul>

<p>String for closing tag. Default value is <code>%]</code></p>

<ul>
<li><code>statementTagModifier</code></li>
</ul>

<p>Modifier to specify the statement instruction. Default value is <code>\</code></p>

<ul>
<li><code>expressionTagModifier</code></li>
</ul>

<p>Modifier to specify the unescaped expression. Default value is <code>=</code></p>

<h1 id="whitespacehandling">WHITESPACE HANDLING</h1>

<p>The rules for whitespace processing:</p>

<ul>
<li><p>First of all, leading and trailing whitespace on each line is trimmed.</p></li>
<li><p>If the control flow statement is followed with the newline, that newline will be "ate" and don't included into template's output. </p></li>
<li><p>All other whitespace (including newlines after expressions) is preserved.</p></li>
</ul>

<h1 id="templatestructure">TEMPLATE STRUCTURE</h1>

<p>You may skip this section for the first-time reading.</p>

<h2 id="emptytemplatebody">Empty template body</h2>

<p>In the simplest case of empty template body, the template function looks like:</p>

<pre><code>    function (stash) { 
        this.startContext(); 

        eval(this.expandStashToVarsCode(stash));

        return this.endContext(); 
    }
</code></pre>

<p>This function accepts a single argument, which should be an <code>Object</code> (in JavaScript meaning) and which is called <em>stash</em>.</p>

<p>This statement</p>

<pre><code>    eval(this.expandStashToVarsCode(stash));
</code></pre>

<p>creates a local variable for each key of the stash, so later, any key of the stash can accessed directly by its name.</p>

<p>Stash can be also accessed directly, if you prefer:</p>

<pre><code>    [% stash.name %]

    [% stash.person.name %]
</code></pre>

<h2 id="ordinarytext">Ordinary text</h2>

<p>If the template contains an ordinary text, like:</p>

<pre><code>    foo 'bar'
</code></pre>

<p>its translated as:</p>

<pre><code>    function (stash) { 
        this.startContext(); 

        eval(this.expandStashToVarsCode(stash));

        __contexts[0].output.push('foo  \'bar\'\\n', "");

        return this.endContext(); 
    }
</code></pre>

<h2 id="escapedexpression">Escaped expression</h2>

<pre><code>    [% name[1] %]
</code></pre>

<p>Corresponds to:</p>

<pre><code>    function (stash) {
        this.startContext();

        eval(this.expandStashToVarsCode(stash));

        __contexts[0].output.push(__me.escapeXml( name[1] ), "");

        return this.endContext();
    }
</code></pre>

<p>Note:
 - Whitespace immediately after opening tag / before closing tag is preserved.
 - A semicolon <em>is</em> added after expression.</p>

<h2 id="unescapedexpression">Unescaped expression</h2>

<pre><code>    [%= name[1] %]
</code></pre>

<p>Is just passed through:</p>

<pre><code>    function (stash) {
        this.startContext();

        eval(this.expandStashToVarsCode(stash));

        __contexts[0].output.push( name[1] , "");

        return this.endContext();
    }
</code></pre>

<h2 id="statements">Statements</h2>

<pre><code>    [%\ 
        for(var i in stash) {
            this.someFunc(p1, p2) 
        } 
    %]
</code></pre>

<p>Is passed through <em>completely</em> unmodified. <em>No semi-colons</em> are appended.</p>

<pre><code>    function (stash) {
        this.startContext();
        eval(this.expandStashToVarsCode(stash));
        for(var i in stash) {
            this.someFunc(p1, p2) 
        } 
        return this.endContext();
    }    
</code></pre>

<p>This means you need to care about any needed punctuation (as with usual code).
For example this template  </p>

<pre><code>    [%\ for(var i in stash) { %][%\ this.echo('123') %][%\ this.echo('123') } %]
</code></pre>

<p>will produce        </p>

<pre><code>    missing ; before statement
</code></pre>

<p>error. To fix it, add punctuation:</p>

<pre><code>    [%\ for(var i in stash) { %][%\ this.echo('123'); %][%\ this.echo('123') } %]
</code></pre>

<h1 id="gettinghelp">GETTING HELP</h1>

<p>This extension is supported via github issues tracker: <a href="http://github.com/SamuraiJack/Shotenjin/issues">http://github.com/SamuraiJack/Shotenjin/issues</a></p>

<p>For general Joose questions you can also visit <a href="http://webchat.freenode.net/?randomnick=1&amp;channels=joose&amp;prompt=1">#joose</a> 
on irc.freenode.org or mailing list at: <a href="http://groups.google.com/group/joose-js">http://groups.google.com/group/joose-js</a></p>

<h1 id="acknowledgements">ACKNOWLEDGEMENTS</h1>

<p>Many thanks to Makoto Kuwata for his Tenjin implementation, on which this engine is based. </p>

<h1 id="seealso">SEE ALSO</h1>

<p>Port of Template::Toolkit to JavaScript: <a href="http://jemplate.net/">Jemplate</a></p>

<p>Google solution: <a href="http://code.google.com/closure/templates/">Closure Templates</a></p>

<p>Templating solution of the ExtJS framework: <a href="http://www.extjs.com/deploy/dev/docs/?class=Ext.XTemplate">Ext.XTemplate</a></p>

<p>General documentation for Joose: <a href="http://joose.github.com/Joose/doc/html/Joose.html">http://joose.github.com/Joose/doc/html/Joose.html</a></p>

<h1 id="bugs">BUGS</h1>

<p>All complex software has bugs lurking in it, and this module is no exception.</p>

<p>Please report any bugs through the web interface at <a href="http://github.com/SamuraiJack/Shotenjin/issues">http://github.com/SamuraiJack/Shotenjin/issues</a></p>

<h1 id="authors">AUTHORS</h1>

<p>Nickolay Platonov <a href="mailto:nplatonov@cpan.org">nplatonov@cpan.org</a></p>

<h1 id="copyrightandlicense">COPYRIGHT AND LICENSE</h1>

<p>Copyright (c) 2011, Nickolay Platonov</p>

<p>All rights reserved.</p>

<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>

<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of Nickolay Platonov nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. </li>
</ul>

<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</body>
</html>